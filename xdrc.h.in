// -*- C++ -*-
// Warning: Make sure to edit xdrc.h.in, not xdrc.h.
# 4 "xdrc.h.in"

/** \file xdrc.h Type definitions for xdrc compiler output. */

#ifndef _XDRC_H_HEADER_INCLUDED_
#define _XDRC_H_HEADER_INCLUDED_ 1

#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <string>

namespace xdr {

#ifndef WORDS_BIGENDIAN
//! Default value set on build machine, but can be overridden (by
//! defining WORDS_BIGENDIAN to 0 or 1) in case of cross-compilation.
#define WORDS_BIGENDIAN @IS_BIG_ENDIAN@
#endif // !WORDS_BIGENDIAN

//! True on big endian machines, false on little endian machines.
#if WORDS_BIGENDIAN
constexpr bool is_big_endian = true;
#else // !WORDS_BIGENDIAN
constexpr bool is_big_endian = false;
#endif // !WORDS_BIGENDIAN

template<std::uint32_t N = 0xffffffff> class xstring : private std::string {
  static void range_check(size_t n) {
    if (n > max_size())
      throw std::out_of_range("xstring overflow");
  }

  static void assign_check(const std::string &s) { range_check(s.size()); }
  template<std::uint32_t M> static void assign_check(const xstring<M> &x) {
    if (M > N)
      assign_check(x.str());
  }
  static void assign_check(const std::initializer_list<char> &il) {
    range_check(il.size());
  }

  void append_check(size_t n) const {
    if (n > max_size() - size())
      throw std::out_of_range("xstring overflow");
  }

public:
  using string = std::string;
  const string &str() const { return *this; }

  using string::npos;
  using string::begin;
  using string::end;
  using string::rbegin;
  using string::rend;
  using string::cbegin;
  using string::cend;
  using string::crbegin;
  using string::crend;
  using string::size;
  using string::length;
  static constexpr std::size_t max_size() { return N; }
  void resize(size_t n) { range_check(n); string::resize(n); }
  void resize(size_t n, char c) { range_check(n); string::resize(n, c); }
  using string::capacity;
  void reserve(size_t n = 0) { range_check(n); string::reserve(n); }
  using string::clear;
  using string::empty;
  using string::shrink_to_fit;
  using string::operator[];
  using string::at;
  using string::back;
  using string::front;

  xstring &operator+=(char c) {
    append_check(1);
    string::operator+=(c);
    return *this;
  }
  template<typename S> xstring &operator+=(const S&s) { return append(s); }

  xstring &append(const string &s) {
    append_check(s.size());
    return string::append(s);
    return *this;
  }
  xstring &append(const string &s, size_t pos, size_t len) {
    append_check(len);
    string::append(s, pos, len);
    return *this;
  }
  xstring &append(const char *s) { return append(s, std::strlen(s)); }
  xstring &append(const char *s, size_t len) {
    append_check(len);
    string::append(s, len);
    return *this;
  }
  string &append (size_t n, char c) {
    append_check(n);
    string::append(n, c);
    return *this;
  }
  template <class I> xstring &append (I first, I last) {
    append_check(last - first);
    string::append(first, last);
    return *this;
  }
  xstring &append(std::initializer_list<char> il) {
    append_check(il.size());
    string::append(il);
    return *this;
  }

  void push_back(char c) { append_check(1); string::push_back(1); }

  template<typename T> xstring &assign(T &&t) {
    assign_check(t);
    string::assign(std::forward<T>(t));
    return *this;
  }
  xstring &assign(const string &s, size_t pos, size_t len) {
    range_check(len);
    string::assign(s, pos, len);
    return *this;
  }
  xstring &assign(const char *s) { return assign(s, std::strlen(s)); }
  xstring &assign(const char *s, size_t len) {
    range_check(len);
    string::assign(s, len);
    return *this;
  }
  string &assign (size_t n, char c) {
    range_check(n);
    string::assign(n, c);
    return *this;
  }
  template <class I> xstring &assign (I first, I last) {
    range_check(last - first);
    string::assign(first, last);
    return *this;
  }
  // XXX insert
  using string::erase;
  // XXX replace
  void swap(string &s) { assign_check(s); string::swap(s); }
  void swap(xstring &s) { string::swap(s); }
  using string::pop_back;
  using string::c_str;
  using string::data;
  char *data() { return &(*this)[0]; } // protobufs does this, so probably ok
  using string::copy;
  using string::find;
  using string::rfind;
  using string::find_first_of;
  using string::find_last_of;
  using string::find_first_not_of;
  using string::find_last_not_of;
  using string::substr;

  using string::compare;
  template<std::uint32_t M> int compare(const xstring<M> &s) {
    return string::compare(s);
  }
};



}

#endif // !_XDRC_H_HEADER_INCLUDED_
